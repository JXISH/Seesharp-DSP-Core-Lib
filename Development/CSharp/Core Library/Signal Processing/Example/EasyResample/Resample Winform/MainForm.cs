/*******************************************
  * Resample example
  * delay is Delay points
  * dt is the new Sampling rate (assuming the Sampling rate of the input signal is 1, dt is greater than the downsampling, dt is less than 1 bit up sampling)
  * sin is the signal to be Re-sampling
  * sinResample is the signal after Re-sampling
  * Note:
  * 1. Due to the Filter in Resample, there will be a delay in the signal after Re-sampling, and the delay Sampling points is 85.
  * 2. When the After sampling is dropped, the new Sampling rate does not satisfy the Nyquist sampling theorem, which causes spectral aliasing.
  * At this time, because the Filter is performed before Re-sampling, the high frequency component is filtered out.
  * 3. The length of sinResample is (sin.Length-85*2)/dt
  * *****************************************/
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using SeeSharpTools.JY.ArrayUtility;
using SeeSharpTools.JXI.SignalProcessing.Conditioning.EasyResample;
using SeeSharpTools.JXI.SignalProcessing.Generation;
using System.Numerics;

namespace Resample_Winform
{
    public partial class MainForm : Form
    {
        #region Private Field       
        #endregion

        #region Constructor
        public MainForm()
        {
            InitializeComponent();
        }
        #endregion

        #region Event Handler
        /// <summary>
        /// Start button
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void buttonResample_Click(object sender, EventArgs e)
        {
            //Get parameters
            int length = (int)numericUpDownSamples.Value;//Sampling points
            double sampleRate = (double)numericUpDownSampleRate.Value;//Sampling rate
            double frequency = (double)numericUpDownFrequency.Value;//Signal frequency
            double delay = (double)numericUpDownDelay.Value;//Delay points
            double dt = (double)numericUpDownDt.Value;

            if (comboBoxType.Text == "Real")
            {
                //Generating a signal to be resampled
                double[] sin = new double[length];
                Generation.SineWave(ref sin, 1, 0, frequency, sampleRate);

                //Re-sampling
                var sinResample = EasyResample.ResampleWaveform(sin, delay, dt);
                double[] sin2 = new double[sinResample.Length];//According to the delay and the filter, the required number of points (85) and the signal generated by dt are established.
                double[,] sin1 = new double[sinResample.Length, 2];//Pre-synchronization signal
                double[,] sinT = new double[2, sinResample.Length];//Pre-synchronization signal
                Generation.SineWave(ref sin2, 1, (delay + 85) * 360 * frequency / sampleRate, frequency, sampleRate / dt);
                ArrayManipulation.Connected_2D_Array(sinResample, sin2, ref sin1);//Grouping two-dimensional arrays
                ArrayManipulation.Transpose(sin1, ref sinT);//Transpose
                                                            //Display
                easyChartAfter.Plot(sinT);//After sampling
                easyChartBefore.Plot(sin);//Before sampling
            }
            else
            {
                //Generating a signal to be resampled
                double[] sin = new double[length];
                double[] cos = new double[length];
                double[,] dataPlay = new double[length,2];
                double[,] dataPlayT = new double[2,length ];
                Generation.SineWave(ref sin, 1, 0, frequency, sampleRate);//Real
                Generation.SineWave(ref cos, 1, 90, frequency, sampleRate);//Imaginary
                ArrayManipulation.Connected_2D_Array(sin, cos, ref dataPlay);//Grouping two-dimensional arrays
                ArrayManipulation.Transpose(dataPlay, ref dataPlayT);//Transpose
                Complex[] data= new Complex[length];
                for (int i = 0; i < length; i++)
                {
                    data[i] = new Complex(sin[i],cos[i]);
                }

                //Re-sampling
                var dataResample = EasyResample.ResampleWaveform(data, delay, dt);

                double[] sin2 = new double[dataResample.Length];//According to the delay and the filter, the required number of points (85) and the signal generated by dt are established.
                double[,] sinT = new double[4, dataResample.Length];//Before and after synchronization
                double[] cos2 = new double[dataResample.Length];//According to the delay and the filter, the required number of points (85) and the signal generated by dt are established.
                Generation.SineWave(ref sin2, 1, (delay + 85) * 360 * frequency / sampleRate, frequency, sampleRate / dt);
                Generation.SineWave(ref cos2, 1, 90+(delay + 85) * 360 * frequency / sampleRate, frequency, sampleRate / dt);

                //Take Real-Imaginary after Re-sampling
                double[] dataResampleReal = new double[dataResample.Length];
                double[] dataResampleIm = new double[dataResample.Length];
                for (int i = 0; i < dataResample.Length; i++)
                {
                    dataResampleReal[i] = dataResample[i].Real;
                    dataResampleIm[i] = dataResample[i].Imaginary;
                }

                //Combination array drawing
                InsetArray(ref sinT, sin2, 0);
                InsetArray(ref sinT, dataResampleReal, 1);
                InsetArray(ref sinT, cos2, 2);
                InsetArray(ref sinT, dataResampleIm, 3);
                //Display
                easyChartAfter.Plot(sinT);//After sampling
                easyChartBefore.Plot(dataPlayT);//Before sampling
            }


        }
        #endregion

        #region Methods
        /// <summary>
        /// Copy a one-dimensional array to a specified column of a two-dimensional array
        /// </summary>
        /// <param name="array2D">Two-dimensional array</param>
        /// <param name="array">One-dimensional array</param>
        /// <param name="index">Column</param>
        private void InsetArray(ref double[,] array2D, double[] array, int index)
        {
            for (int i = 0; i < Math.Min(array.Length, array2D.GetLength(1)); i++)
            {
                array2D[index, i] = array[i];
            }
        }
        #endregion
    }
}
